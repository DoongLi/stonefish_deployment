
/*
 * Copyright (c) 2020 Iqua Robotics SL - All Rights Reserved
 *
 * This file is subject to the terms and conditions defined in file
 * 'LICENSE.txt', which is part of this source code package.
 */

#include <cola2_control/low_level_controllers/auv_controller_base.h>
#include <cola2_control/low_level_controllers/only_thruster_allocator.h>
#include <cola2_control/low_level_controllers/only_thrusters_controller.h>

OnlyThrustersController::OnlyThrustersController(double period, unsigned int n_thrusters)
  : IAUVController(period, 6, n_thrusters)
  , n_thrusters_(n_thrusters)
  , pose_controller_(6)
  , twist_controller_(6)
  , twist_poly_controller_(6)
  , thruster_allocator_(n_thrusters)
{
  // Init controllers
  initPoseController();
  initTwistController();
  initTwistPolyController();
}

void OnlyThrustersController::initPoseController()
{
  p_surge_ = std::shared_ptr<PID>(new PID("pose_surge"));
  pose_controller_.addController(p_surge_);

  p_sway_ = std::shared_ptr<PID>(new PID("pose_sway"));
  pose_controller_.addController(p_sway_);

  p_heave_ = std::shared_ptr<PID>(new PID("pose_heave"));
  pose_controller_.addController(p_heave_);

  p_roll_ = std::shared_ptr<PID>(new PID("pose_roll"));
  pose_controller_.addController(p_roll_);

  p_pitch_ = std::shared_ptr<PID>(new PID("pose_pitch"));
  pose_controller_.addController(p_pitch_);

  p_yaw_ = std::shared_ptr<PID>(new PID("pose_yaw"));
  pose_controller_.addController(p_yaw_);
}

void OnlyThrustersController::initTwistController()
{
  t_surge_ = std::shared_ptr<PID>(new PID("twist_surge"));
  twist_controller_.addController(t_surge_);

  t_sway_ = std::shared_ptr<PID>(new PID("twist_sway"));
  twist_controller_.addController(t_sway_);

  t_heave_ = std::shared_ptr<PID>(new PID("twist_heave"));
  twist_controller_.addController(t_heave_);

  t_roll_ = std::shared_ptr<PID>(new PID("twist_roll"));
  twist_controller_.addController(t_roll_);

  t_pitch_ = std::shared_ptr<PID>(new PID("twist_pitch"));
  twist_controller_.addController(t_pitch_);

  t_yaw_ = std::shared_ptr<PID>(new PID("twist_yaw"));
  twist_controller_.addController(t_yaw_);
}

void OnlyThrustersController::initTwistPolyController()
{
  tp_surge_ = std::shared_ptr<Poly>(new Poly("twist_poly_surge"));
  twist_poly_controller_.addController(tp_surge_);

  tp_sway_ = std::shared_ptr<Poly>(new Poly("twist_poly_sway"));
  twist_poly_controller_.addController(tp_sway_);

  tp_heave_ = std::shared_ptr<Poly>(new Poly("twist_poly_heave"));
  twist_poly_controller_.addController(tp_heave_);

  tp_roll_ = std::shared_ptr<Poly>(new Poly("twist_poly_roll"));
  twist_poly_controller_.addController(tp_roll_);

  tp_pitch_ = std::shared_ptr<Poly>(new Poly("twist_poly_pitch"));
  twist_poly_controller_.addController(tp_pitch_);

  tp_yaw_ = std::shared_ptr<Poly>(new Poly("twist_poly_yaw"));
  twist_poly_controller_.addController(tp_yaw_);
}

void OnlyThrustersController::setControllerParams(const std::vector<std::map<std::string, double> > p_params,
                                                  const std::vector<std::map<std::string, double> > t_params,
                                                  const std::vector<std::map<std::string, double> > poly_params)
{
  pose_controller_.setControllerParams(p_params);
  twist_controller_.setControllerParams(t_params);
  twist_poly_controller_.setControllerParams(poly_params);
  pose_controller_.reset();
  twist_controller_.reset();
  twist_poly_controller_.reset();
}

void OnlyThrustersController::reset()
{
  pose_controller_.reset();
  twist_controller_.reset();
  twist_poly_controller_.reset();
}

void OnlyThrustersController::iteration(double current_time)
{
  // Merge pose requests
  Request desired_pose = pose_merge_.merge(current_time);
  merged_pose_ = desired_pose;

  if (getIsPoseControllerEnable())
  {
    // Initialize the twist req. that will be generated by the pose controller
    Request velocity_req(desired_pose);

    // Disable Pitch control
    std::vector<bool> disable_axis = velocity_req.getDisabledAxis();
    // disable_axis.at(4) = true;
    velocity_req.setDisabledAxis(disable_axis);

    // Compute pose error
    std::vector<double> pose_error = computeError(desired_pose.getValues(), pose_feedback_);

    // If desired pose in is near to 0 and current pose is near to 0 disable Z axis
    if (pose_feedback_.at(2) < 1.0 && desired_pose.getValues().at(2) < 1.0)
    {
      // Disable Heave control
      std::vector<bool> disable_axis = velocity_req.getDisabledAxis();
      disable_axis.at(2) = true;
      velocity_req.setDisabledAxis(disable_axis);
      // std::cout << "Disable Z axis because to close to surface\n";
    }

    // Compute PID between pose error and zero
    // desired_pose.setValues(pose_error);
    std::vector<double> zero(6, 0.0);
    // std::vector<double> pose_ctrl_tau = pose_controller_.compute(current_time, desired_pose, zero);
    Request zero_request_with_correct_disable_axis(desired_pose);
    zero_request_with_correct_disable_axis.setValues(zero);
    const std::vector<double> negative_pose_error = { -pose_error[0], -pose_error[1], -pose_error[2],
                                                      -pose_error[3], -pose_error[4], -pose_error[5] };
    std::vector<double> pose_ctrl_tau =
        pose_controller_.compute(current_time, zero_request_with_correct_disable_axis, negative_pose_error);

    // Normalize output to max velocity
    assert(pose_ctrl_tau.size() == max_velocity_.size());
    for (unsigned int i = 0; i < pose_ctrl_tau.size(); i++)
    {
      pose_ctrl_tau.at(i) = pose_ctrl_tau.at(i) * max_velocity_.at(i);
    }

    // Depth PID instead of heave PID. Use pitch to convert from vertical velocity in world
    // frame to surge and heave velocities
    /*std::cerr << "-------------------" << std::endl;
    std::cerr << "Depth velocity: " << pose_ctrl_tau[2] << std::endl;*/
    const double V_depth_measured = -twist_feedback_[0] * std::sin(pose_feedback_[4]);
    const double V_depth_error = pose_ctrl_tau[2] - V_depth_measured;
    pose_ctrl_tau[0] -= V_depth_error * std::sin(pose_feedback_[4]);
    pose_ctrl_tau[2] = V_depth_error * std::cos(pose_feedback_[4]);
    /*pose_ctrl_tau[0] -= pose_ctrl_tau[2] * std::sin(pose_feedback_[4]);
    pose_ctrl_tau[2] *= std::cos(pose_feedback_[4]);*/
    disable_axis = velocity_req.getDisabledAxis();
    disable_axis[0] = !((!disable_axis[0]) || (!disable_axis[2]));
    velocity_req.setDisabledAxis(disable_axis);
    /*std::cerr << "Surge velocity: " << pose_ctrl_tau[0] << std::endl;
    std::cerr << "Heave velocity: " << pose_ctrl_tau[2] << std::endl;
    std::cerr << "disable_axis[0] = " << (disable_axis[0] ? "True" : "False") << std::endl;
    std::cerr << "disable_axis[2] = " << (disable_axis[2] ? "True" : "False") << std::endl;*/

    // Add Pose controller response to body velocity requests
    velocity_req.setValues(pose_ctrl_tau);
    // std::cout << "pose controller result: \n" << velocity_req << std::endl;
    twist_merge_.addRequest(velocity_req);
  }

  // Merge twist request
  Request desired_twist = twist_merge_.merge(current_time);

  // Set zero velocity if depth is greater than threshold
  if (pose_feedback_.at(2) > set_zero_velocity_depth_)
  {
    // Get values and disable axis
    std::vector<double> values = desired_twist.getValues();
    std::vector<bool> disable_axis = desired_twist.getDisabledAxis();

    // Modify according to config
    bool all_disabled = true;
    bool at_least_one_modified = false;
    for (std::size_t i = 0; i < disable_axis.size(); ++i)
    {
      if (!disable_axis[i])
      {
        all_disabled = false;
      }
      else if (set_zero_velocity_axes_[i])
      {
        at_least_one_modified = true;
        values[i] = 0.0;
        disable_axis[i] = false;
      }
    }

    // Set the modified values
    desired_twist.setValues(values);
    desired_twist.setDisabledAxis(disable_axis);

    // Change priority and requester if necessary
    if (at_least_one_modified && all_disabled)
    {
      desired_twist.setPriority(set_zero_velocity_priority_);
      desired_twist.setRequester("set_zero_velocity");
    }
  }

  // Assign merged twist
  merged_twist_ = desired_twist;

  if (getIsVelocityControllerEnable())
  {
    // Initialize the wrench_req req. that will be generated by the twist controller
    Request wrench_req(desired_twist);

    // Compute twist control (and set the resulting wrench req.)
    std::vector<double> pid_twist = twist_controller_.compute(current_time, desired_twist, twist_feedback_);

    std::vector<double> poly_twist = twist_poly_controller_.compute(current_time, desired_twist, twist_feedback_);

    assert(pid_twist.size() == poly_twist.size());
    std::vector<double> total;
    for (unsigned int i = 0; i < pid_twist.size(); i++)
    {
      // std::cout << i << ") PID: " << pid_twist.at(i) << ", Poly: " << poly_twist.at(i) << "\n";
      total.push_back(cola2::utils::saturate(
          cola2::utils::saturate(pid_twist.at(i), 1.0) * max_wrench_.at(i) + poly_twist.at(i), max_wrench_.at(i)));
      // std::cout << "PID " << i << ": " <<  pid_twist.at(i) << "\n";
      // std::cout << "Poly " << i << ": " <<  poly_twist.at(i) << "\n";
      // std::cout << "total " << i << ": " <<  total.at(i) << "\n";
    }

    wrench_req.setValues(total);

    // std::cout << "Twist controller result: \n" << wrench_req << std::endl;
    wrench_merge_.addRequest(wrench_req);
  }

  // Merge wrench req. and save them
  merged_wrench_ = wrench_merge_.merge(current_time);
}

std::vector<double> OnlyThrustersController::computeError(const std::vector<double> setpoint,
                                                          const std::vector<double> feedback)
{
  // WARNING: This function is intended for 6 DoF controllers only!
  assert(setpoint.size() == 6);
  assert(feedback.size() == 6);

  std::vector<double> error(6, 0.0);
  poseError(setpoint, feedback, error);
  error.at(2) = setpoint.at(2) - feedback.at(2);
  error.at(3) = cola2::utils::wrapAngle(setpoint.at(3) - feedback.at(3));
  error.at(4) = cola2::utils::wrapAngle(setpoint.at(4) - feedback.at(4));
  error.at(5) = cola2::utils::wrapAngle(setpoint.at(5) - feedback.at(5));

  return error;
}

void OnlyThrustersController::poseError(const std::vector<double> setpoint, const std::vector<double> feedback,
                                        std::vector<double>& error)
{
  double yaw = feedback.at(5);
  Eigen::MatrixXd m(3, 3);
  m(0, 0) = std::cos(yaw);
  m(0, 1) = -std::sin(yaw);
  m(0, 2) = 0.0;
  m(1, 0) = std::sin(yaw);
  m(1, 1) = std::cos(yaw);
  m(1, 2) = 0.0;
  m(2, 0) = 0.0;
  m(2, 1) = 0.0;
  m(2, 2) = 1.0;

  Eigen::MatrixXd p(3, 1);
  p(0, 0) = feedback.at(0);
  p(1, 0) = feedback.at(1);
  p(2, 0) = 0.0;

  Eigen::MatrixXd aux = -m.transpose() * p;

  Eigen::MatrixXd T(4, 4);
  T(0, 0) = m.transpose()(0, 0);
  T(0, 1) = m.transpose()(0, 1);
  T(0, 2) = m.transpose()(0, 2);
  T(0, 3) = aux(0, 0);
  T(1, 0) = m.transpose()(1, 0);
  T(1, 1) = m.transpose()(1, 1);
  T(1, 2) = m.transpose()(1, 2);
  T(1, 3) = aux(1, 0);
  T(2, 0) = m.transpose()(2, 0);
  T(2, 1) = m.transpose()(2, 1);
  T(2, 2) = m.transpose()(2, 2);
  T(2, 3) = aux(2, 0);
  T(3, 0) = 0.0;
  T(3, 1) = 0.0;
  T(3, 2) = 0.0;
  T(3, 3) = 1.0;

  Eigen::MatrixXd p_req(4, 1);
  p_req(0, 0) = setpoint.at(0);
  p_req(1, 0) = setpoint.at(1);
  p_req(2, 0) = 0.0;
  p_req(3, 0) = 1.0;

  Eigen::MatrixXd distance = T * p_req;
  error.at(0) = distance(0, 0);
  error.at(1) = distance(1, 0);
}

void OnlyThrustersController::computeThrusterAllocator()
{
  if (getIsThrusterAllocatorEnable())
  {
    thruster_setpoints_ = thruster_allocator_.compute(merged_wrench_);
  }
}

unsigned int OnlyThrustersController::getNumberofThrusters() const
{
  return n_thrusters_;
}
